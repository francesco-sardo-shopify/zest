const w=(t,e)=>e.some(n=>t instanceof n);let B,D;function P(){return B||(B=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function x(){return D||(D=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const l=new WeakMap,h=new WeakMap,b=new WeakMap;function M(t){const e=new Promise((n,o)=>{const r=()=>{t.removeEventListener("success",a),t.removeEventListener("error",s)},a=()=>{n(d(t.result)),r()},s=()=>{o(t.error),r()};t.addEventListener("success",a),t.addEventListener("error",s)});return b.set(e,t),e}function A(t){if(l.has(t))return;const e=new Promise((n,o)=>{const r=()=>{t.removeEventListener("complete",a),t.removeEventListener("error",s),t.removeEventListener("abort",s)},a=()=>{n(),r()},s=()=>{o(t.error||new DOMException("AbortError","AbortError")),r()};t.addEventListener("complete",a),t.addEventListener("error",s),t.addEventListener("abort",s)});l.set(t,e)}let I={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return l.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return d(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function E(t){I=t(I)}function j(t){return x().includes(t)?function(...e){return t.apply(g(this),e),d(this.request)}:function(...e){return d(t.apply(g(this),e))}}function L(t){return typeof t=="function"?j(t):(t instanceof IDBTransaction&&A(t),w(t,P())?new Proxy(t,I):t)}function d(t){if(t instanceof IDBRequest)return M(t);if(h.has(t))return h.get(t);const e=L(t);return e!==t&&(h.set(t,e),b.set(e,t)),e}const g=t=>b.get(t);function O(t,e,{blocked:n,upgrade:o,blocking:r,terminated:a}={}){const s=indexedDB.open(t,e),f=d(s);return o&&s.addEventListener("upgradeneeded",i=>{o(d(s.result),i.oldVersion,i.newVersion,d(s.transaction),i)}),n&&s.addEventListener("blocked",i=>n(i.oldVersion,i.newVersion,i)),f.then(i=>{a&&i.addEventListener("close",()=>a()),r&&i.addEventListener("versionchange",u=>r(u.oldVersion,u.newVersion,u))}).catch(()=>{}),f}const v=["get","getKey","getAll","getAllKeys","count"],T=["put","add","delete","clear"],y=new Map;function p(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(y.get(e))return y.get(e);const n=e.replace(/FromIndex$/,""),o=e!==n,r=T.includes(n);if(!(n in(o?IDBIndex:IDBObjectStore).prototype)||!(r||v.includes(n)))return;const a=async function(s,...f){const i=this.transaction(s,r?"readwrite":"readonly");let u=i.store;return o&&(u=u.index(f.shift())),(await Promise.all([u[n](...f),r&&i.done]))[0]};return y.set(e,a),a}E(t=>({...t,get:(e,n,o)=>p(e,n)||t.get(e,n,o),has:(e,n)=>!!p(e,n)||t.has(e,n)}));const V=["continue","continuePrimaryKey","advance"],k={},m=new WeakMap,C=new WeakMap,N={get(t,e){if(!V.includes(e))return t[e];let n=k[e];return n||(n=k[e]=function(...o){m.set(this,C.get(this)[e](...o))}),n}};async function*W(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const n=new Proxy(e,N);for(C.set(n,e),b.set(n,g(e));e;)yield n,e=await(m.get(n)||e.continue()),m.delete(n)}function S(t,e){return e===Symbol.asyncIterator&&w(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&w(t,[IDBIndex,IDBObjectStore])}E(t=>({...t,get(e,n,o){return S(e,n)?W:t.get(e,n,o)},has(e,n){return S(e,n)||t.has(e,n)}}));const F="zest-library",K=1;async function c(){return O(F,K,{upgrade(t,e){if(t.objectStoreNames.contains("books")||t.createObjectStore("books",{keyPath:"id"}).createIndex("by-updated-at","updatedAt"),t.objectStoreNames.contains("settings")||t.createObjectStore("settings",{keyPath:"id"}),!t.objectStoreNames.contains("chats")){const n=t.createObjectStore("chats",{keyPath:"id"});n.createIndex("by-book-id","bookId"),n.createIndex("by-updated-at","updatedAt")}}})}async function R(t){return(await c()).put("books",t)}async function _(){const e=(await c()).transaction("books").objectStore("books").index("by-updated-at"),n=[];let o=await e.openCursor(null,"prev");for(;o;)n.push(o.value),o=await o.continue();return n}async function z(t){const n=await(await c()).get("books",t);if(!n)throw new Error("Book not found");return n}async function $(t){const e=await c();return t.updatedAt=new Date,e.put("books",t)}async function G(t){return(await c()).delete("books",t)}async function H(){return(await c()).get("settings","llm-settings")}async function J(t){const e=await c(),n={...t,id:"llm-settings",updatedAt:new Date};return e.put("settings",n)}async function Q(t){return(await c()).put("chats",t)}async function U(t){return(await c()).get("chats",t)}async function X(t){const e=await c();return t.updatedAt=new Date,e.put("chats",t)}async function Y(t){const n=(await c()).transaction("chats").objectStore("chats").index("by-book-id"),o=[];let r=await n.openCursor(t);for(;r;)o.push(r.value),r=await r.continue();return o.sort((a,s)=>s.updatedAt.getTime()-a.updatedAt.getTime())}export{R as addBook,Q as addChat,G as deleteBook,_ as getAllBooks,z as getBook,U as getChat,Y as getChatsByBookId,H as getSettings,c as initDB,J as saveSettings,$ as updateBook,X as updateChat};
